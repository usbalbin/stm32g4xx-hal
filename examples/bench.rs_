#![no_main]
#![no_std]

use crate::hal::{
    adc::{config::SampleTime, AdcClaim, ClockSource},
    delay::SYSTDelayExt,
    rcc::Config,
    stm32::Peripherals,
};
use hal::prelude::*;
use stm32g4xx_hal as hal;

use cortex_m::peripheral::DWT;
use cortex_m_rt::entry;

use utils::logger::info;

#[macro_use]
mod utils;

macro_rules! bench {
    ($data:expr, $op:ident, $($arg:expr, )*) => {{
        let start_cyc = DWT::cycle_count();
        for i in 0..10000  {
            $data = $data.$op($($arg, )*);
        }
        let cycles = DWT::cycle_count() - start_cyc;

        defmt::info!("$op: {} cycles - {}", cycles, $data);
    }};
}

#[entry]
fn main() -> ! {
    defmt::info!("init");

    let dp = Peripherals::take().unwrap();
    let cp = cortex_m::Peripherals::take().expect("cannot take core peripherals");

    let rcc = dp.RCC.constrain();
    let mut rcc = rcc.freeze(Config::hsi());

    info!("Setup Adc1");
    let mut delay = cp.SYST.delay(&rcc.clocks);
    let mut adc = dp
        .ADC1
        .claim(ClockSource::SystemClock, &rcc, &mut delay, true);

    info!("Setup Gpio");

    let gpioa = dp.GPIOA.split(&mut rcc);
    let pa0 = gpioa.pa0.into_analog();

    let sample = adc.convert(&pa0, SampleTime::Cycles_640_5) as f32;

    info!("Enter Loop");

    let mut data = sample;

    bench!(data, sin,);
    bench!(data, sqrt,);
    bench!(data, atan2, sample,);
    bench!(data, atan2, sample,);

    info!("done!");
    loop {}
}

/// Hardware sqrt
fn hsqrt(x: f32) -> f32 {
    let mut result: f32;
    unsafe {
        core::arch::asm!(
            "VSQRT.F32 {}, {}",
            out(sreg) result, // Sreg for fpu register
            in(sreg) x,
        );
    }

    result
}
